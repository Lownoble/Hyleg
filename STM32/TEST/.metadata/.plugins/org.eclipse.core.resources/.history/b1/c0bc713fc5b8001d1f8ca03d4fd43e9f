/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    spi.c
  * @brief   This file provides code for the configuration
  *          of the SPI instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "spi.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

SPI_HandleTypeDef hspi2;
SPI_HandleTypeDef hspi3;

/* SPI2 init function */
void MX_SPI2_Init(void)
{

  /* USER CODE BEGIN SPI2_Init 0 */

  /* USER CODE END SPI2_Init 0 */

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  hspi2.Instance = SPI2;
  hspi2.Init.Mode = SPI_MODE_SLAVE;
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI2_Init 2 */
  else printf("\nSPI2 start success!!!\n");
  /* USER CODE END SPI2_Init 2 */

}
/* SPI3 init function */
void MX_SPI3_Init(void)
{

  /* USER CODE BEGIN SPI3_Init 0 */

  /* USER CODE END SPI3_Init 0 */

  /* USER CODE BEGIN SPI3_Init 1 */

  /* USER CODE END SPI3_Init 1 */
  hspi3.Instance = SPI3;
  hspi3.Init.Mode = SPI_MODE_MASTER;
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
  hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi3.Init.NSS = SPI_NSS_SOFT;
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi3.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI3_Init 2 */
  else printf("\nSPI3 start success!!!\n");
  /* USER CODE END SPI3_Init 2 */

}

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(spiHandle->Instance==SPI2)
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* SPI2 clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**SPI2 GPIO Configuration
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }
  else if(spiHandle->Instance==SPI3)
  {
  /* USER CODE BEGIN SPI3_MspInit 0 */

  /* USER CODE END SPI3_MspInit 0 */
    /* SPI3 clock enable */
    __HAL_RCC_SPI3_CLK_ENABLE();

    __HAL_RCC_GPIOC_CLK_ENABLE();
    /**SPI3 GPIO Configuration
    PC10     ------> SPI3_SCK
    PC11     ------> SPI3_MISO
    PC12     ------> SPI3_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }
}

void HAL_SPI_MspDeInit(SPI_HandleTypeDef* spiHandle)
{

  if(spiHandle->Instance==SPI2)
  {
  /* USER CODE BEGIN SPI2_MspDeInit 0 */

  /* USER CODE END SPI2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_SPI2_CLK_DISABLE();

    /**SPI2 GPIO Configuration
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);

  /* USER CODE BEGIN SPI2_MspDeInit 1 */

  /* USER CODE END SPI2_MspDeInit 1 */
  }
  else if(spiHandle->Instance==SPI3)
  {
  /* USER CODE BEGIN SPI3_MspDeInit 0 */

  /* USER CODE END SPI3_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_SPI3_CLK_DISABLE();

    /**SPI3 GPIO Configuration
    PC10     ------> SPI3_SCK
    PC11     ------> SPI3_MISO
    PC12     ------> SPI3_MOSI
    */
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12);

  /* USER CODE BEGIN SPI3_MspDeInit 1 */
	SPI_CS(NRF2401,1);
	SPI_CS(MPU9250,1);
	SPI_CS(CS_FLASH,1);
	SPI_CS(MS5611,1);
	SPI_CS(CS_LIS,1);
  /* USER CODE END SPI3_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

uint8_t Spi_RW(uint8_t Txdata)
{
//	while (SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_TXE) == RESET);
//	SPI_I2S_SendData(SPI3, dat);
//	while (SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_RXNE) == RESET);
//	return SPI_I2S_ReceiveData(SPI3);
	uint8_t Rxdata;
	if(HAL_SPI_TransmitReceive(&hspi3,&Txdata,&Rxdata,1,1000) == HAL_OK)
	{
		return Rxdata;
	}
	else
		printf("\nSPI receive failed!!!\n");
	return 9;
}


void SPI_Receive(uint8_t *pData, uint16_t Size)
{
    for(uint16_t i=0; i<Size; i++)
    {
        pData[i] = Spi_RW(0);
    }
}

void SPI_CS(uint8_t sel,uint8_t set)
{
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5,GPIO_PIN_SET);
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,GPIO_PIN_SET);
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15,GPIO_PIN_SET);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,GPIO_PIN_SET);
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4,GPIO_PIN_SET);
	HAL_Delay(1);
switch(sel)
{
	case MPU9250:
		if(set)
			HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5,GPIO_PIN_SET);
		else
			HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5,GPIO_PIN_RESET);
		break;
	case NRF2401:
		if(set)
			HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4,GPIO_PIN_SET);
		else
			HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4,GPIO_PIN_RESET);
		break;
	case MS5611:
		if(set)
			HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,GPIO_PIN_SET);
		else
			HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,GPIO_PIN_RESET);
		break;
	case CS_FLASH:
		if(set)
			HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,GPIO_PIN_SET);
		else
			HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,GPIO_PIN_RESET);
		break;
	case CS_LIS:
		if(set)
			HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15,GPIO_PIN_SET);
		else
			HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15,GPIO_PIN_RESET);
		break;
}
}


//-----------------------------SPI通信--------------------------------

static __IO uint32_t  TimeOut = SPIT_LONG_TIMEOUT;
int spi_master_connect_pi=0;
int spi_master_loss_pi=0;
int spi_comm_mess_type=0;
unsigned char  spi_tx_buf[SPI_BUF_SIZE]={0};
unsigned char  spi_rx_buf[SPI_BUF_SIZE]={0};
int spi_tx_cnt=0;
int spi_rx_cnt=0;
int spi_rx_cnt_all=0;
char spi_flag_pi[2]={0,0};
float spi_dt[10]={0};
uint8_t SPI_Send_Byte(u16 data)
{
	TimeOut = SPIT_LONG_TIMEOUT;
	while(SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_TXE) == RESET)
	{}
	SPI_I2S_SendData(SPI2,data);
	TimeOut = SPIT_LONG_TIMEOUT;
	while(SPI_I2S_GetFlagStatus(SPI2,SPI_I2S_FLAG_RXNE) == RESET)
	{}
	return SPI_I2S_ReceiveData(SPI2);
}

static void setDataInt_spi(int i)
{
	spi_tx_buf[spi_tx_cnt++] = ((i << 24) >> 24);
	spi_tx_buf[spi_tx_cnt++] = ((i << 16) >> 24);
	spi_tx_buf[spi_tx_cnt++] = ((i << 8) >> 24);
	spi_tx_buf[spi_tx_cnt++] = (i >> 24);
}

static void setDataFloat_spi(float f)
{
	int i = *(int *)&f;
	spi_tx_buf[spi_tx_cnt++] = ((i << 24) >> 24);
	spi_tx_buf[spi_tx_cnt++] = ((i << 16) >> 24);
	spi_tx_buf[spi_tx_cnt++] = ((i << 8) >> 24);
	spi_tx_buf[spi_tx_cnt++] = (i >> 24);
}

static void setDataFloat_spi_int(float f,float size)
{
	vs16 _temp;
	_temp=f*size;
	spi_tx_buf[spi_tx_cnt++] = BYTE1(_temp);
	spi_tx_buf[spi_tx_cnt++] = BYTE0(_temp);
}


static float floatFromData_spi(unsigned char *data,int* anal_cnt)
{
	int i = 0x00;
	i |= (*(data+*anal_cnt+3) << 24);
	i |= (*(data+*anal_cnt+2) << 16);
	i |= (*(data+*anal_cnt+1) << 8);
	i |= (*(data+*anal_cnt+0));

	*anal_cnt +=4;
	return *(float *)&i;
}

static float floatFromData_spi_int(unsigned char *data, int *anal_cnt,float size)
{
	float temp=0;
	temp=(float)((int16_t)(*(data + *anal_cnt + 0)<<8)|*(data + *anal_cnt + 1))/size;
	*anal_cnt += 2;
	return temp;
}

static char charFromData_spi(unsigned char *data,int* anal_cnt)
{
	int temp=*anal_cnt ;
	*anal_cnt +=1;
	return *(data+temp);
}

static int intFromData_spi(unsigned char *data,int* anal_cnt)
{
	int i = 0x00;
	i |= (*(data+*anal_cnt+3) << 24);
	i |= (*(data+*anal_cnt+2) << 16);
	i |= (*(data+*anal_cnt+1) << 8);
	i |= (*(data+*anal_cnt+0));
	*anal_cnt +=4;
	return i;
}

//for slave
void slave_send(char sel)
{
  int i;
	char id=0;
	char sum_t=0,_cnt=0;

	spi_tx_cnt=0;

	spi_tx_buf[spi_tx_cnt++]=0xFF;
	spi_tx_buf[spi_tx_cnt++]=0xFB;
	spi_tx_buf[spi_tx_cnt++]=sel;
	spi_tx_buf[spi_tx_cnt++]=0;
	switch(sel)
	{

	case 24://STM32的整体发送//-----------use now==============2022/4/14 多路Sbus
		setDataFloat_spi(robotwb.now_att.pitch);
		setDataFloat_spi(robotwb.now_att.roll);
		setDataFloat_spi(robotwb.now_att.yaw);

		setDataFloat_spi(robotwb.now_rate.pitch);
		setDataFloat_spi(robotwb.now_rate.roll);
		setDataFloat_spi(robotwb.now_rate.yaw);

		setDataFloat_spi(vmc_all.acc_b.x);//机体加速度
		setDataFloat_spi(vmc_all.acc_b.y);
		setDataFloat_spi(vmc_all.acc_b.z);

		setDataFloat_spi(vmc_all.acc_nn.x);//全局加速度
		setDataFloat_spi(vmc_all.acc_nn.y);
		setDataFloat_spi(vmc_all.acc_nn.z);

		for(id=0;id<4;id++){
			setDataFloat_spi_int(leg_motor[id].q_now[0],CAN_POS_DIV);//关节角度
			setDataFloat_spi_int(leg_motor[id].q_now[1],CAN_POS_DIV);
			setDataFloat_spi_int(leg_motor[id].q_now[2],CAN_POS_DIV);

			setDataFloat_spi_int(leg_motor[id].t_now[0],CAN_T_DIV);//关节扭矩
			setDataFloat_spi_int(leg_motor[id].t_now[1],CAN_T_DIV);
			setDataFloat_spi_int(leg_motor[id].t_now[2],CAN_T_DIV);

			spi_tx_buf[spi_tx_cnt++]=(leg_motor[id].connect*100+leg_motor[id].connect_motor[0]*10+leg_motor[id].ready[0]);//驱动状态
			spi_tx_buf[spi_tx_cnt++]=(leg_motor[id].connect*100+leg_motor[id].connect_motor[1]*10+leg_motor[id].ready[1]);
			spi_tx_buf[spi_tx_cnt++]=(leg_motor[id].connect*100+leg_motor[id].connect_motor[2]*10+leg_motor[id].ready[2]);
		}
		setDataFloat_spi_int(leg_motor[id].bat_v[0],100);

		//sbus 10通道航模
		setDataFloat_spi_int(Rc_Get_SBUS.SBUS_CH[0],100);
		setDataFloat_spi_int(Rc_Get_SBUS.SBUS_CH[1],100);
		setDataFloat_spi_int(Rc_Get_SBUS.SBUS_CH[2],100);
		setDataFloat_spi_int(Rc_Get_SBUS.SBUS_CH[3],100);
		setDataFloat_spi_int(Rc_Get_SBUS.SBUS_CH[4],100);
		setDataFloat_spi_int(Rc_Get_SBUS.SBUS_CH[5],100);
		spi_tx_buf[spi_tx_cnt++]=Rc_Get_SBUS.connect*100+(Rc_Get_SBUS.AUX_SEL1+1)*10+(Rc_Get_SBUS.AUX_SEL2+1);
		spi_tx_buf[spi_tx_cnt++]=(Rc_Get_SBUS.AUX_SEL3+1)*10+(Rc_Get_SBUS.AUX_SEL4+1);
		spi_tx_buf[spi_tx_cnt++]=(Rc_Get_SBUS.AUX_SEL5+1)*10+(Rc_Get_SBUS.AUX_SEL6+1);

		//UWB track 空循环 面阵UWB定位模块
		setDataFloat_spi_int(g_nltaoa_nodeframe0.result.nodes[0]->dis,100);
		setDataFloat_spi_int(g_nltaoa_nodeframe0.result.nodes[0]->angle,10);
		spi_tx_buf[spi_tx_cnt++]=fabs(g_nltaoa_nodeframe0.result.nodes[0]->rx_rssi)*g_nltaoa_nodeframe0.connect;

		//arm 机械臂反馈
	    setDataFloat_spi_int(arm_cmd_s.pos_now.x,20);
		setDataFloat_spi_int(arm_cmd_s.pos_now.y,20);
		setDataFloat_spi_int(arm_cmd_s.pos_now.z,20);
		setDataFloat_spi_int(arm_cmd_s.att_now[0],20);
		setDataFloat_spi_int(arm_cmd_s.att_now[1],20);
		setDataFloat_spi_int(arm_cmd_s.att_now[2],20);
	break;
	}
	spi_tx_buf[3] =(spi_tx_cnt)-4;
		for( i=0;i<spi_tx_cnt;i++)
	sum_t += spi_tx_buf[i];
	spi_tx_buf[spi_tx_cnt++] = sum_t;

}

float test_spi_rx[2]={0};
int sum_spi_err=0;
int temp_sel[4][128]={0};
void slave_rx(uint8_t *data_buf,uint8_t num)//---------------------------从控制器接收
{ static uint8_t cnt[4];
	uint8_t id;
	char temp_char;
	vs16 rc_value_temp;
	uint8_t sum = 0;
	uint8_t i;
	int anal_cnt=4;
	float kp_sw,ki_sw,kd_sw;
	float kp_st,ki_st,kd_st;
	char bldc_id_sel=0;

	for( i=0;i<(num-1);i++)
		sum += *(data_buf+i);
	if(!(sum==*(data_buf+num-1)))		{
		sum_spi_err++;
		i=0;
		return;}		//判断sum
	if(!(*(data_buf)==0xFE && *(data_buf+1)==0xFC))		return;		//判断帧头
  if(*(data_buf+2)==41)//主控的整体接受================================**2022/4/4 3 BLDC param div
  {
		spi_comm_mess_type=SPI_MESS_TYPE_3BLDC_DIV;
		spi_dt[1] = Get_Cycle_T(17);
	  spi_master_loss_pi=0;
		spi_master_connect_pi=1;
		IWDG_Feed();
		for(id=0;id<4;id++){
		robotwb.Leg[id].tar_sita[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);//期望大腿角度
		robotwb.Leg[id].tar_sita[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);//期望小腿角度
		robotwb.Leg[id].tar_sita[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);//期望侧展角度
		leg_motor[id].set_t[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);//期望大腿扭矩
		leg_motor[id].set_t[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);
		leg_motor[id].q_reset[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);//期望大腿标0角度
		leg_motor[id].q_reset[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		leg_motor[id].q_reset[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		leg_motor[id].q_pid_sel=charFromData_spi(spi_rx_buf,&anal_cnt);//底层参数选择0->摆动  1->支撑
		}

		leg_motor[0].t_to_i[0]=leg_motor[0].t_to_i[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);//扭矩系数

		robotwb.Leg[0].q_pid.kp=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_P);//初始化时角度参数 P
		robotwb.Leg[0].q_pid.ki=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_I);
		robotwb.Leg[0].q_pid.kd=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_D);

		kp_sw=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_P);//摆动时角度参数 P
		ki_sw=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_I);
		kd_sw=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_D);

		kp_st=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_P);//支撑时角度参数 P
		ki_st=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_I);
		kd_st=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_D);

		leg_motor[0].max_i[0]=leg_motor[0].max_i[1]=leg_motor[0].max_i[2]=charFromData_spi(spi_rx_buf,&anal_cnt);//最大电流
		leg_motor[0].max_t[0]=leg_motor[0].max_i[0]*leg_motor[0].t_to_i[0];//电流换算扭矩限制

		leg_motor[0].max_t[2]=leg_motor[0].max_t[1]=leg_motor[0].max_t[0];

		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[0].motor_en=rc_value_temp/100;//电机使能
		leg_motor[0].reset_q=(rc_value_temp-leg_motor[0].motor_en*100)/10;//电机标0
		leg_motor[0].reset_err=rc_value_temp%10;//复位故障

		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		bldc_id_sel=rc_value_temp/100;
		io_sel_scp_scl[0]=rc_value_temp/10;//扩展IO控制
		io_sel_scp_scl[1]=rc_value_temp%10;

//--------------50
		mems.imu_att.z=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);//主控陀螺仪安装角度
		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		mems.Acc_CALIBRATE=rc_value_temp/100;//标定加速度计
		mems.Gyro_CALIBRATE=(rc_value_temp-mems.Acc_CALIBRATE*100)/10;//标定陀螺仪
		mems.Mag_CALIBRATE=rc_value_temp%10;//标定磁场
    robotwb.beep_state=charFromData_spi(spi_rx_buf,&anal_cnt);//蜂鸣器状态

//robot_arm
		arm_cmd_s.pos_set.x=floatFromData_spi_int(spi_rx_buf,&anal_cnt,20);//机械臂设置位置
		arm_cmd_s.pos_set.y=floatFromData_spi_int(spi_rx_buf,&anal_cnt,20);
		arm_cmd_s.pos_set.z=floatFromData_spi_int(spi_rx_buf,&anal_cnt,20);
		arm_cmd_s.att_set[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,20);//机械臂设置姿态
		arm_cmd_s.att_set[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,20);
		arm_cmd_s.att_set[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,20);
		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		arm_cmd_s.power=rc_value_temp/10;
		arm_cmd_s.mode=rc_value_temp%10;

		arm_cmd_s.cap=charFromData_spi(spi_rx_buf,&anal_cnt);

 //---------------------------------向变量赋值-----------------------------------
		for(id=0;id<4;id++){
			leg_motor[id].t_to_i[0]=leg_motor[0].t_to_i[0];
			leg_motor[id].t_to_i[1]=leg_motor[0].t_to_i[1];
			leg_motor[id].t_to_i[2]=leg_motor[0].t_to_i[2];
			robotwb.Leg[id].q_pid.kp=robotwb.Leg[0].q_pid.kp;
			robotwb.Leg[id].q_pid.ki=robotwb.Leg[0].q_pid.ki;
			robotwb.Leg[id].q_pid.kd=robotwb.Leg[0].q_pid.kd;

			robotwb.Leg[id].q_pid_sw.kp_d[bldc_id_sel]=kp_sw;
			robotwb.Leg[id].q_pid_sw.ki_d[bldc_id_sel]=ki_sw;
			robotwb.Leg[id].q_pid_sw.kd_d[bldc_id_sel]=kd_sw;
			robotwb.Leg[id].q_pid_st.kp_d[bldc_id_sel]=kp_st;
			robotwb.Leg[id].q_pid_st.ki_d[bldc_id_sel]=ki_st;
			robotwb.Leg[id].q_pid_st.kd_d[bldc_id_sel]=kd_st;

			leg_motor[id].max_i[0]=leg_motor[0].max_i[0];
			leg_motor[id].max_i[1]=leg_motor[0].max_i[1];
			leg_motor[id].max_i[2]=leg_motor[0].max_i[2];
		  leg_motor[id].max_t[0]=leg_motor[0].max_t[0];
			leg_motor[id].max_t[1]=leg_motor[0].max_t[1];
			leg_motor[id].max_t[2]=leg_motor[0].max_t[2];
			leg_motor[id].motor_en=leg_motor[0].motor_en;
			#if !DIV_Q_RESET
			leg_motor[id].reset_q=leg_motor[0].reset_q;
			#endif
			leg_motor[id].reset_err=leg_motor[0].reset_err;
		}
	}
		else if (*(data_buf+2)==50)//OCU mems
  {
		mems.imu_pos.x=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		mems.imu_pos.y=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		mems.imu_pos.z=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		mems.imu_att.x=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		mems.imu_att.y=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		mems.imu_att.z=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		mems.gps_pos.x=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		mems.gps_pos.y=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		mems.gps_pos.z=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		mems.Acc_CALIBRATE=charFromData_spi(spi_rx_buf,&anal_cnt);
		mems.Gyro_CALIBRATE=charFromData_spi(spi_rx_buf,&anal_cnt);
		mems.Mag_CALIBRATE=charFromData_spi(spi_rx_buf,&anal_cnt);
	}

	//------------------------Old version
	if(*(data_buf+2)==1)//
  {
		spi_dt[1] = Get_Cycle_T(17);
	  spi_master_loss_pi=0;
		spi_master_connect_pi=1;
		IWDG_Feed();
		for(id=0;id<4;id++){
		robotwb.Leg[id].tar_sita[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		robotwb.Leg[id].tar_sita[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		leg_motor[id].set_t[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);
		leg_motor[id].set_t[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);
		}
	}
	else if (*(data_buf+2)==2)//
  {
		spi_dt[2] = Get_Cycle_T(18);
		spi_master_loss_pi=0;
		spi_master_connect_pi=1;
		IWDG_Feed();
		for(id=0;id<4;id++){
		leg_motor[id].q_reset[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		leg_motor[id].q_reset[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		}

		leg_motor[0].t_to_i[0]=leg_motor[0].t_to_i[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);//电机零偏复位角度
		robotwb.Leg[0].q_pid.kp=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		robotwb.Leg[0].q_pid.ki=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		robotwb.Leg[0].q_pid.kd=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);

		leg_motor[0].max_i[0]=leg_motor[0].max_i[1]=charFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[0].motor_en=charFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[0].reset_q=charFromData_spi(spi_rx_buf,&anal_cnt);
	  leg_motor[0].reset_err=charFromData_spi(spi_rx_buf,&anal_cnt);
	  rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		io_sel_scp_scl[0]=rc_value_temp/10;
		io_sel_scp_scl[1]=rc_value_temp%10;
		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		thread_running[2]=rc_value_temp/100;
		thread_running[1]=rc_value_temp/10;
		thread_running[0]=rc_value_temp%10;
		for(id=0;id<4;id++){
			leg_motor[id].t_to_i[0]=leg_motor[0].t_to_i[0];
			leg_motor[id].t_to_i[1]=leg_motor[0].t_to_i[1];
			robotwb.Leg[id].q_pid.kp=robotwb.Leg[0].q_pid.kp;
			robotwb.Leg[id].q_pid.ki=robotwb.Leg[0].q_pid.ki;
			robotwb.Leg[id].q_pid.kd=robotwb.Leg[0].q_pid.kd;
			leg_motor[id].max_i[0]=leg_motor[0].max_i[0];
			leg_motor[id].max_i[1]=leg_motor[0].max_i[1];
			leg_motor[id].motor_en=leg_motor[0].motor_en;
			leg_motor[id].reset_q=leg_motor[0].reset_q;
			leg_motor[id].reset_err=leg_motor[0].reset_err;
		}
	}
	else if(*(data_buf+2)==20)//主控的整体接受================================**2022/2/2
  {
		spi_comm_mess_type=0;
		spi_dt[1] = Get_Cycle_T(17);
	  spi_master_loss_pi=0;
		spi_master_connect_pi=1;
		IWDG_Feed();
		for(id=0;id<4;id++){
		robotwb.Leg[id].tar_sita[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		robotwb.Leg[id].tar_sita[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		robotwb.Leg[id].tar_sita[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		leg_motor[id].set_t[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);
		leg_motor[id].set_t[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);
		leg_motor[id].set_t[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);
		leg_motor[id].q_reset[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		leg_motor[id].q_reset[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		leg_motor[id].q_reset[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		leg_motor[id].q_pid_sel=charFromData_spi(spi_rx_buf,&anal_cnt);
		}

		leg_motor[0].t_to_i[0]=leg_motor[0].t_to_i[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);//电机零偏复位角度
		robotwb.Leg[0].q_pid.kp=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_P);
		robotwb.Leg[0].q_pid.ki=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_I);
		robotwb.Leg[0].q_pid.kd=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_D);

		robotwb.Leg[0].q_pid_sw.kp=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_P);
		robotwb.Leg[0].q_pid_sw.ki=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_I);
		robotwb.Leg[0].q_pid_sw.kd=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_D);

		robotwb.Leg[0].q_pid_st.kp=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_P);
		robotwb.Leg[0].q_pid_st.ki=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_I);
		robotwb.Leg[0].q_pid_st.kd=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_GAIN_DIV_D);

		leg_motor[0].max_i[0]=leg_motor[0].max_i[1]=leg_motor[0].max_i[2]=charFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[0].max_t[0]=leg_motor[0].max_i[0]*leg_motor[0].t_to_i[0];

		leg_motor[0].max_t[2]=leg_motor[0].max_t[1]=leg_motor[0].max_t[0];

		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[0].motor_en=rc_value_temp/100;
		leg_motor[0].reset_q=(rc_value_temp-leg_motor[0].motor_en*100)/10;
		leg_motor[0].reset_err=rc_value_temp%10;

		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		io_sel_scp_scl[0]=rc_value_temp/10;
		io_sel_scp_scl[1]=rc_value_temp%10;
//--------------50

		mems.imu_att.z=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		mems.Acc_CALIBRATE=rc_value_temp/100;
		mems.Gyro_CALIBRATE=(rc_value_temp-mems.Acc_CALIBRATE*100)/10;
		mems.Mag_CALIBRATE=rc_value_temp%10;
    robotwb.beep_state=charFromData_spi(spi_rx_buf,&anal_cnt);
 //赋值
		for(id=0;id<4;id++){
			leg_motor[id].t_to_i[0]=leg_motor[0].t_to_i[0];
			leg_motor[id].t_to_i[1]=leg_motor[0].t_to_i[1];
			leg_motor[id].t_to_i[2]=leg_motor[0].t_to_i[2];
			robotwb.Leg[id].q_pid.kp=robotwb.Leg[0].q_pid.kp;
			robotwb.Leg[id].q_pid.ki=robotwb.Leg[0].q_pid.ki;
			robotwb.Leg[id].q_pid.kd=robotwb.Leg[0].q_pid.kd;
			robotwb.Leg[id].q_pid_sw.kp=robotwb.Leg[0].q_pid_sw.kp;
			robotwb.Leg[id].q_pid_sw.ki=robotwb.Leg[0].q_pid_sw.ki;
			robotwb.Leg[id].q_pid_sw.kd=robotwb.Leg[0].q_pid_sw.kd;
			robotwb.Leg[id].q_pid_st.kp=robotwb.Leg[0].q_pid_st.kp;
			robotwb.Leg[id].q_pid_st.ki=robotwb.Leg[0].q_pid_st.ki;
			robotwb.Leg[id].q_pid_st.kd=robotwb.Leg[0].q_pid_st.kd;
			leg_motor[id].max_i[0]=leg_motor[0].max_i[0];
			leg_motor[id].max_i[1]=leg_motor[0].max_i[1];
			leg_motor[id].max_i[2]=leg_motor[0].max_i[2];
		  leg_motor[id].max_t[0]=leg_motor[0].max_t[0];
			leg_motor[id].max_t[1]=leg_motor[0].max_t[1];
			leg_motor[id].max_t[2]=leg_motor[0].max_t[2];
			leg_motor[id].motor_en=leg_motor[0].motor_en;
			leg_motor[id].reset_q=leg_motor[0].reset_q;
			leg_motor[id].reset_err=leg_motor[0].reset_err;
		}

	}

		else if(*(data_buf+2)==31)//主控的整体接受 use now
  {
		spi_dt[1] = Get_Cycle_T(17);
	  spi_master_loss_pi=0;
		spi_master_connect_pi=1;
		IWDG_Feed();
		for(id=0;id<4;id++){
		robotwb.Leg[id].tar_sita[0]=floatFromData_spi(spi_rx_buf,&anal_cnt);
		robotwb.Leg[id].tar_sita[1]=floatFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[id].set_t[0]=floatFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[id].set_t[1]=floatFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[id].q_reset[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		leg_motor[id].q_reset[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		}

		leg_motor[0].t_to_i[0]=leg_motor[0].t_to_i[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);//电机零偏复位角度

		robotwb.Leg[0].q_pid.kp=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		robotwb.Leg[0].q_pid.ki=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		robotwb.Leg[0].q_pid.kd=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);

	//OCU param
		mems.imu_att.z=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		robotwb.beep_state=charFromData_spi(spi_rx_buf,&anal_cnt);
		temp_char=charFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[0].motor_en=temp_char/100;
		leg_motor[0].reset_q=temp_char/10;
		leg_motor[0].reset_err=temp_char%10;

		leg_motor[0].max_i[0]=leg_motor[0].max_i[1]=charFromData_spi(spi_rx_buf,&anal_cnt);

		temp_char=charFromData_spi(spi_rx_buf,&anal_cnt);
		mems.Acc_CALIBRATE=(temp_char>>7)&0x01;
		mems.Gyro_CALIBRATE=(temp_char>>6)&0x01;
		mems.Mag_CALIBRATE=(temp_char>>5)&0x01;
		io_sel_scp_scl[0]=(temp_char>>4)&0x01;
		io_sel_scp_scl[1]=(temp_char>>3)&0x01;

		for(id=0;id<4;id++){
			leg_motor[id].t_to_i[0]=leg_motor[0].t_to_i[0];
			leg_motor[id].t_to_i[1]=leg_motor[0].t_to_i[1];
			robotwb.Leg[id].q_pid.kp=robotwb.Leg[0].q_pid.kp;
			robotwb.Leg[id].q_pid.ki=robotwb.Leg[0].q_pid.ki;
			robotwb.Leg[id].q_pid.kd=robotwb.Leg[0].q_pid.kd;
			leg_motor[id].max_i[0]=leg_motor[0].max_i[0];
			leg_motor[id].max_i[1]=leg_motor[0].max_i[1];
			leg_motor[id].motor_en=leg_motor[0].motor_en;
			leg_motor[id].reset_q=leg_motor[0].reset_q;
			leg_motor[id].reset_err=leg_motor[0].reset_err;
		}

	}
//-------------------CAN_LINK_COMM_VER1--------------------
	else if(*(data_buf+2)==21)//主控的整体接受1
  {
		spi_dt[1] = Get_Cycle_T(17);
	  spi_master_loss_pi=0;
		spi_master_connect_pi=1;
		IWDG_Feed();
		for(id=0;id<4;id++){
			robotwb.Leg[id].tar_sita[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
			robotwb.Leg[id].tar_sita[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
			robotwb.Leg[id].tar_sita[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
			leg_motor[id].set_t[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);
			leg_motor[id].set_t[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);
			leg_motor[id].set_t[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_T_DIV);
			robotwb.Leg[id].q_pid.param_sel=charFromData_spi(spi_rx_buf,&anal_cnt);
			temp_sel[id][cnt[id]++]=robotwb.Leg[id].q_pid.param_sel;
		}
		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		leg_motor[0].motor_en=rc_value_temp/100;
		leg_motor[0].reset_q=rc_value_temp/10;
		leg_motor[0].reset_err=rc_value_temp%10;

		for(id=0;id<4;id++){
			leg_motor[id].motor_en=leg_motor[0].motor_en;
			leg_motor[id].reset_q=leg_motor[0].reset_q;
			leg_motor[id].reset_err=leg_motor[0].reset_err;
		}
	}

	else if(*(data_buf+2)==22)//主控的整体接受2
  {
		spi_dt[2] = Get_Cycle_T(18);
	  spi_master_loss_pi=0;
		spi_master_connect_pi=1;
		IWDG_Feed();
		for(id=0;id<4;id++){
		  leg_motor[id].q_reset[0]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		  leg_motor[id].q_reset[1]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
			leg_motor[id].q_reset[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		}

		leg_motor[0].t_to_i[0]=leg_motor[0].t_to_i[1]=leg_motor[0].t_to_i[2]=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);//电机零偏复位角度

		mems.imu_att.x=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);
		mems.imu_att.z=floatFromData_spi_int(spi_rx_buf,&anal_cnt,CAN_POS_DIV);

		robotwb.Leg[0].q_pid.kp_sw=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		robotwb.Leg[0].q_pid.ki_sw=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		robotwb.Leg[0].q_pid.kd_sw=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);

		robotwb.Leg[0].q_pid.kp_st=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		robotwb.Leg[0].q_pid.ki_st=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);
		robotwb.Leg[0].q_pid.kd_st=floatFromData_spi_int(spi_rx_buf,&anal_cnt,1000);


		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		mems.Acc_CALIBRATE=rc_value_temp/100;
		mems.Gyro_CALIBRATE=rc_value_temp/10;
		mems.Mag_CALIBRATE=rc_value_temp%10;

		rc_value_temp=charFromData_spi(spi_rx_buf,&anal_cnt);
		robotwb.beep_state=rc_value_temp/100;
		io_sel_scp_scl[0]=rc_value_temp/10;
		io_sel_scp_scl[1]=rc_value_temp%10;

		leg_motor[0].max_i[0]=leg_motor[0].max_i[1]=leg_motor[0].max_i[2]=charFromData_spi(spi_rx_buf,&anal_cnt);

		for(id=0;id<4;id++){
			leg_motor[id].t_to_i[0]=leg_motor[0].t_to_i[0];
			leg_motor[id].t_to_i[1]=leg_motor[0].t_to_i[1];
			leg_motor[id].t_to_i[2]=leg_motor[0].t_to_i[2];
			robotwb.Leg[id].q_pid.kp=robotwb.Leg[0].q_pid.kp_sw;
			robotwb.Leg[id].q_pid.ki=robotwb.Leg[0].q_pid.ki_sw;
			robotwb.Leg[id].q_pid.kd=robotwb.Leg[0].q_pid.kd_sw;
			robotwb.Leg[id].q_pid.kp_sw=robotwb.Leg[0].q_pid.kp_sw;
			robotwb.Leg[id].q_pid.ki_sw=robotwb.Leg[0].q_pid.ki_sw;
			robotwb.Leg[id].q_pid.kd_sw=robotwb.Leg[0].q_pid.kd_sw;
			robotwb.Leg[id].q_pid.kp_st=robotwb.Leg[0].q_pid.kp_st;
			robotwb.Leg[id].q_pid.ki_st=robotwb.Leg[0].q_pid.ki_st;
			robotwb.Leg[id].q_pid.kd_st=robotwb.Leg[0].q_pid.kd_st;
			leg_motor[id].max_i[0]=leg_motor[0].max_i[0];
			leg_motor[id].max_i[1]=leg_motor[0].max_i[1];
			leg_motor[id].max_i[2]=leg_motor[0].max_i[2];
		}
	}

	else if (*(data_buf+2)==99)//
  {
		spi_dt[2] = Get_Cycle_T(18);

		test_spi_rx[0]=floatFromData_spi(spi_rx_buf,&anal_cnt);
		test_spi_rx[1]=floatFromData_spi(spi_rx_buf,&anal_cnt);
	}

}

uint8_t SPI2_ReadWriteByte_s(uint8_t TxData)
{

  while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET){}//等待发送区空    使用if的话发送不稳定容易

	SPI_I2S_SendData(SPI2, TxData); //通过外设SPIx发送一个byte  数据
}


void SPI2_IRQHandler(void)//目前无用采用   DMA1_Stream4_IRQHandler中断进行SPI数据通信
{
	static char state=0,rx_cnt;
	static int spi_tx_cnt_send=0;
	char sum_r=0;
	int i,j;
	unsigned char  data_temp[8];
	char err,_cnt;
	char id;
	static uint8_t _data_len2 = 0,_data_cnt2 = 0;
	uint16_t data;
	static int send_flag=0;
	static float timer_sys=0;
	if (SPI_I2S_GetITStatus(SPI2, SPI_I2S_IT_TXE) != RESET) {
			SPI2_ReadWriteByte_s(spi_tx_buf[spi_tx_cnt_send++]);
			if(spi_tx_cnt_send>=spi_tx_cnt&&spi_flag_pi[1]==0)//发送完毕可以重新赋值
			{ spi_flag_pi[1]=1;
			}
	}

	if(SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) != RESET)
	{
		if(spi_flag_pi[1]==1){//data can change
			spi_flag_pi[1]=0;
			spi_dt[0] = Get_Cycle_T(16);

			timer_sys+=spi_dt[0];
			if(timer_sys>0.1){timer_sys=0;
				slave_send(3);//系统状态
			}else{
				if(send_flag==1){
				send_flag=0;
				slave_send(1);//姿态
				}//发送数据重新赋值
				else{
				send_flag=1;
				slave_send(2);
				}
			}
			 spi_tx_cnt_send=0;
		}

		data = SPI_I2S_ReceiveData(SPI2);//中断读取SPI数据

		if(state==0&&data==0xFB)
		{
			state=1;
			spi_rx_buf[0]=data;
		}
		else if(state==1&&data==0xFC)
		{
			state=2;
			spi_rx_buf[1]=data;
		}
		else if(state==2&&data>0&&data<0XF1)
		{
			state=3;
			spi_rx_buf[2]=data;
		}
		else if(state==3&&data<SPI_BUF_SIZE)
		{
			state = 4;
			spi_rx_buf[3]=data;
			_data_len2 = data;
			_data_cnt2 = 0;
		}
		else if(state==4&&_data_len2>0)
		{
			_data_len2--;
			spi_rx_buf[4+_data_cnt2++]=data;
			if(_data_len2==0)
				state= 5;
		}
		else if(state==5)
		{
			state = 0;
			spi_rx_buf[4+_data_cnt2]=data;
			spi_rx_cnt=4;
			slave_rx(spi_rx_buf,_data_cnt2+5);
			spi_rx_cnt_all++;
		}
		else
			state = 0;

		//同步发送
		if(spi_tx_cnt_send>=spi_tx_cnt&&spi_flag_pi[1]==0)//发送完毕可以重新赋值
		{ spi_flag_pi[1]=1;
		}else
			SPI2_ReadWriteByte_s(spi_tx_buf[spi_tx_cnt_send++]);
	}
}


/* USER CODE END 1 */
